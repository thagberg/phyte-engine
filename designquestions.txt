------------------------------------
How do key events become moves?
------------------------------------

key events are mapped to move names (lp, walk, jump, fireball...)
move names are mapped to move indices
currently combo inputs are mapped to move indices, but this should probably be
	broken up.  Move determination logic should now capture the name of a
	move, which will then be used to lookup the move index at the last
	point before changing the player's current move

done [X]

------------------------------------
How do moves cancel into special, super, or target combo moves?
------------------------------------

I think there are two avenues to explore for this one.  The (possibly) simplest
	would be to assign each move an analog "priority" value.  Move cancels 
	would be determined by comparing the priority of the move in execution 
	and the move whose input has just been satisfied.

The second, perhaps more complicated method, but in my opinion probably the
	better one, would be to establish "categories" of moves, similar to
	way player states work.  Move cancels would be determined through an 
	algorithm of switches, comparing the category of the executing move to 
	the move whose input has been satisfied.

In the end, I decided to define an explicit list of moves which can be cancelled to
    for each move.  This might become a pain-in-the-ass to maintain, but it's also
    easy to set up and easy to understand.  It will also simplify rekka-like moves
    (for example, 3 moves defined in a row with the same input, that way the first 
    one will always execute first, with cancel path established to make the whole 
    rekka work)

done [X]

------------------------------------
How do "charged" inputs get recognized?
------------------------------------

I think the cleanest solution for this (which may introduce a bit of additional
    CPU overhead...) would be to add an attribute to each input in the buffer which
    keeps track of the number of frames for which that input has been held.
    Obviously this means that when I'm gathering the current input state, I will
    need to compare it to the previous input state, and increment any inputs
    which exist in both states.  Any inputs that existed in the previous state
    which no longer exist in the current state will be reset to 0 frames held.

done [ ]

------------------------------------
How do I manage current and previous input states (to ensure you can't juse hold the punch button) ?
------------------------------------

This will probably just get taken care of with the solution to the previous question

done [ ]

------------------------------------
How do I convert "left" or "right" into "forward" or "backward" when checking input buffers?
------------------------------------

Welp, this was actually pretty easy

done [X]

